import { sendToBackend } from './js/SendToBackend.js';


/*
  عند تحميل الصفحة:
  - يتم توليد مربعات التحقق (واحد حقيقي و4 وهميين).
  - يتم إخفاء كل شيء تقريبًا باستخدام CSS.
  - يتم تفعيل حماية زمنية (لا يُسمح بالنقر فورًا).
*/

let realCheckboxReference = null; // فقط نخزن مرجعه بالذاكرة
let allowClick = false;  //ميزة التأخير الزمني العشوائي بين ظهور المربعات والسماح بالنقر


// 🔧 دوال مساعدة لتحسين منطق التحقق
// ✅ التحقق مما إذا كان النقر سريعًا جدًا (أقل من 300ms)
function isClickTooFast(timeDiff) {
    return timeDiff !== null && timeDiff < 300;
}
// ✅ التحقق مما إذا كانت النقرة في المنتصف تمامًا (ضمن هامش الخطأ)
function isCenterClick(diffX, diffY, tolerance = 1) {
    return diffX < tolerance && diffY < tolerance;
}




// ✅ عند تحميل الصفحة بالكامل: ابدأ تنفيذ إعداد CAPTCHA (إنشاء المربعات والتحقق من الأحداث)
document.addEventListener("DOMContentLoaded", () => {
    const checkboxContainer = document.getElementById("checkbox-container");
    const captchaBox = document.querySelector(".captcha-box");


    let userInteraction = {
        lastTime: 0,
        lastX: 0,
        lastY: 0,
        mouseMoved: false
    };

    function showMessage(text, type = "info") {
        const msgEl = document.getElementById("captcha-message");
        msgEl.textContent = text;
        msgEl.className = "captcha-message";
        msgEl.classList.add(type);
    }

    // 🟢 تتبع حركة الماوس
    document.addEventListener("mousemove", (event) => {
        if (Math.abs(event.movementX) > 1 || Math.abs(event.movementY) > 1) {
            userInteraction.mouseMoved = true;
        }
    });

    // 🟢 إنشاء مربعات
    function createCheckBoxes() {
        let checkboxes = [];
        for (let i = 0; i < 4; i++) {
            let checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.classList.add("hidden-checkbox");
            checkboxes.push(checkbox);
        }

        let realCheckbox = document.createElement("input");
        realCheckbox.type = "checkbox";
        realCheckbox.classList.add("hidden-checkbox");
        realCheckboxReference = realCheckbox;

        realCheckbox.style.outline = "2px solid limegreen"; // فقط للاختبار

        let possiblePositions = [1, 3];
        let randomIndex = possiblePositions[Math.floor(Math.random() * possiblePositions.length)];
        checkboxes.splice(randomIndex, 0, realCheckbox);

        return checkboxes;
    }

    function shuffleCheckBoxes() {
        checkboxContainer.innerHTML = "";
        let newCheckBoxes = createCheckBoxes();
        newCheckBoxes.forEach(c => checkboxContainer.appendChild(c));
        allowClick = false;

        const delay = 500 + Math.random() * 1000;
        setTimeout(() => {
            allowClick = true;
            console.log(`🟢 السماح بالنقر بعد ${Math.round(delay)}ms`);
        }, delay);
    }

    shuffleCheckBoxes();

    checkboxContainer.addEventListener("click", (event) => {
        let now = Date.now();
        let clickX = event.clientX;
        let clickY = event.clientY;
        let timeDiff = userInteraction.lastTime ? now - userInteraction.lastTime : null;

        userInteraction.lastTime = now;

        let distance = Math.sqrt(Math.pow(clickX - userInteraction.lastX, 2) + Math.pow(clickY - userInteraction.lastY, 2));

        if (!allowClick || isClickTooFast(timeDiff) || !userInteraction.mouseMoved || distance < 10) {
            console.warn("❌ نقر مشبوه");
            event.preventDefault();
            return;
        }

        if (event.target === realCheckboxReference) {
            let rect = event.target.getBoundingClientRect();
            let diffX = Math.abs(clickX - (rect.left + rect.width / 2));
            let diffY = Math.abs(clickY - (rect.top + rect.height / 2));

            if (isCenterClick(diffX, diffY)) {
                console.warn("🤖 نقرة مثالية! محتمل روبوت");
                event.preventDefault();
                return;
            }

            console.log("✅ اجتاز التحقق");
            showMessage("✅ تم التحقق بنجاح!", "success");
            MouseTracker.handleClick(event);
        } else {
            console.warn("⚠️ اختيار خاطئ. إعادة المحاولة");
            showMessage("⚠️ هذا ليس المربع الصحيح، حاول مرة أخرى.", "warning");
            shuffleCheckBoxes();
        }

        userInteraction.lastX = clickX;
        userInteraction.lastY = clickY;
        userInteraction.mouseMoved = false;
    });

    // ✅ ربط تتبع الحركة داخل captcha-box
    if (captchaBox) {
        captchaBox.addEventListener("mouseenter", (event) => MouseTracker.startTracking(event));
        captchaBox.addEventListener("mousemove", (event) => MouseTracker.trackMovement(event));
    }
});




// 1️⃣ يتتبع سرعة الماوس فقط عند دخوله captcha-box.
// 2️⃣ يخزن فقط آخر 5 سرعات لحساب معدل التباطؤ (decelerationRate).
// 3️⃣ عند النقر على real-checkbox، يقوم بإنشاء JSON يتضمن:

const MouseTracker = {
    entryTime: null,
    speedLog: [],
    maxSpeed: 0,
    suddenStopCount: 0,
    trackingActive: false,

    startTracking(event) {
        this.entryTime = Date.now();
        this.speedLog = [];
        this.maxSpeed = 0;
        this.suddenStopCount = 0;
        this.trackingActive = true;
    },

    trackMovement(event) {
        if (!this.trackingActive) return;

        let dx = event.movementX;
        let dy = event.movementY;
        let speed = Math.sqrt(dx * dx + dy * dy);

        if (speed > 0.5) {
            this.speedLog.push(speed);
            if (speed > this.maxSpeed) this.maxSpeed = speed;

            // ✅ حساب عدد التوقفات المفاجئة
            if (this.speedLog.length > 1 && this.speedLog[this.speedLog.length - 2] > 2 && speed < 0.5) {
                this.suddenStopCount++;
            }

            // ✅ الاحتفاظ فقط بآخر 10 سرعات
            if (this.speedLog.length > 10) {
                this.speedLog.shift();
            }
        }
    },

    handleClick(event) {
        if (!this.trackingActive) return;

        let clickTime = Date.now();
        let movementTime = clickTime - this.entryTime;
        let lastSpeed = this.speedLog.length > 0 ? this.speedLog[this.speedLog.length - 1] : 0;

        // ✅ تحسين `decelerationRate` ليكون أكثر دقة
        let lastSpeeds = this.speedLog.slice(-5);
        let avgLastSpeed = lastSpeeds.length > 0 ? lastSpeeds.reduce((a, b) => a + b, 0) / lastSpeeds.length : 0;
        let decelerationRate = avgLastSpeed > 0 ? (avgLastSpeed - lastSpeed) / avgLastSpeed : 0;
        decelerationRate = decelerationRate < 0 ? 0 : parseFloat(decelerationRate.toFixed(2)); // منع القيم السلبية غير المنطقية

        // ✅ تحسين `speedStability` ليأخذ في الاعتبار التغير الطبيعي للبشر
        let meanSpeed = this.speedLog.length > 0 ? this.speedLog.reduce((a, b) => a + b, 0) / this.speedLog.length : 0;
        let speedVariance = this.speedLog.length > 1 ? this.speedLog.reduce((sum, speed) => sum + Math.pow(speed - meanSpeed, 2), 0) / this.speedLog.length : 0;
        let speedStability = Math.sqrt(speedVariance);
        speedStability = parseFloat(speedStability.toFixed(2));

        // ✅ إضافة `movementPattern` لتحليل نمط الحركة
        let movementPattern = "normal";
        if (speedStability < 0.1) {
            movementPattern = "too stable"; // الروبوتات تتحرك بثبات غير طبيعي
        } else if (speedStability > 2.0) {
            movementPattern = "chaotic"; // البشر عادة لا يتحركون بفوضوية شديدة
        }

        // ✅ تحسين `behaviorType`
        let behaviorType = "human";
        let uncertainConditions = 0;

        if (movementTime < 200) uncertainConditions++; // وقت الحركة قصير جدًا
        if (speedStability < 0.1) uncertainConditions++; // السرعة ثابتة جدًا
        if (decelerationRate < 0.2) uncertainConditions++; // لا يوجد تباطؤ كافٍ
        if (this.suddenStopCount > 3) uncertainConditions++; // عدد التوقفات المفاجئة كبير

        if (uncertainConditions >= 2) {
            behaviorType = "uncertain"; // إذا كان هناك أكثر من عامل غير طبيعي
        }

        // 🟢 تحويل البيانات إلى JSON
        let jsonData = {
            maxSpeed: parseFloat(this.maxSpeed.toFixed(2)),
            lastSpeed: parseFloat(lastSpeed.toFixed(2)),
            decelerationRate: decelerationRate,
            decelerationRatio: Math.round((this.maxSpeed - lastSpeed) / this.maxSpeed * 100),
            speedStability: speedStability,
            movementTime: movementTime,
            suddenStopCount: this.suddenStopCount,
            speedTrend: decelerationRate > 0.6 ? "gradual" : "sharp",
            movementPattern: movementPattern,
            behaviorType: behaviorType
        };

        // 📌 عرض JSON في الكونسول لاختبار البيانات
        console.log("📌 JSON Data:", JSON.stringify(jsonData, null, 2));


        // 🟢 إرسال البيانات إلى API  to BackEnd from SendToBackend.js
        sendToBackend(jsonData);


        // 🔄 إعادة ضبط القيم بعد النقر
        this.trackingActive = false;
    }



};


